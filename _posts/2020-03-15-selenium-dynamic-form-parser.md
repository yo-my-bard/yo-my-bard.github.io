---
layout: post
title: "Function Follows Form: An Approach to Dynamically Parsing and Filling HTML Forms Using Selenium"
date: 2020-03-15
categories: [Python, Selenium, Automation]
---
For this post, I'm writing about a process in which I mostly pieced together puzzle pieces as I went along.

I talked a little about defining larger dreams for oneself in the previous post, but I can't emphasize enough how much programming has really unlocked possibilities in my imagination. About a year ago, I was working on an automation work flow that relies on Selenium and Python. At the time, the slickest trick that I really knew is that on Chrome, you can Inspect an HTML object and copy its xpath value into your script to make magic happen.
[pictures, maybe even GIFs, here please of the inspect process and the driver.find_element_by_xpath]
This trick did wonders for my work and I leveled up quite a bit. We were often working with websites that didn't always use IDs on their HTML elements and their class attributes were often too general to try to narrow down. However, as time went on, I realized that I needed to start playing around with more general xpath. I was constantly Googling to see if I can find a go-to resource on xpath but I wasn't finding much luck. I think there are hard copy resources out there but I wasn't exactly trying to go all in on being a baller at xpath. The little that I have picked up over the course of the last few of months have led me here.

## The Problem
I have a website that has a bunch of reports that I would like to download in various formats. Upon logging into that website, you can go to a "Reports Page" that lists all of the reports: Report A, Report B, Report C, etc. If you click Report A, you are led to a website that has 10 report elements that you can customize and click "View Report" on. The web page then uses AJAX to produce the report below the form. If I click Report B, I get the same structure, but the report elements are not guaranteed to be the same, and honestly, I'm not even sure if they are always on the same part of the page from report to report as a result of this. A year ago, I attempted to write an API that covered general use cases (i.e. left most options as the default options and exposed only a few through the API). Suffice it to say, it felt lackluster and worse still, the method call was very unwieldy. Some of the logic was faulty and I felt that it stemmed from a lack of understanding of how to deal with a form with **so many** options. Having leveled up since then, I started asking how general could I make this form processing.
[Give example HTML structures]

## The Opportunity
Because I don't work directly with the folks that make the website that I'm trying to use Selenium on, I can't ask them to structure their webpage in a more convenient manner. However, I felt I picked up enough xpath that I could try to dynamically produce the form elements and expose them to the user as available options.

## Initial Viability Assessment
I went back to the drawing board with fresh eyes. I opened two of the reporting pages and tried to parse the HTML that created the form to try to see if there was a structure hidden under all that messiness. It was hard to see the end of the tunnel honestly -- the form elements were nested in table elements and for dropdowns, it wasn't immediately clear how I would access the dropdown options. Despite this, I was starting to see a pattern in the structure. At a high level, all form elements were housed in a div with an attribute called `data-parametername`. I didn't know how I was going to go down the rabbit hole and parse the precise input element housed in the div, but this pattern made it seem like a real possibility. I then took a step back to read whethere HTML form elements are marked in a way that makes it clear that they belong to this form and are a data field for the form. A read of the [MDN webpage](link here) suggested some key look-fors, namely the name attribute. Looking at my webpage, the name attribute has some hard to parse values that probably make sense to the backend but wouldn't be helpful for my dynamic parser even if I could manage to pull out all the name values. The existence of the `data-parametername` and the fact that it covered all of the form elements, and only the form elements, was promising enough for me to continue the journey forward. If you're looking to do some dynamic form parsing yourself, I think this parser viability assessment is applicable to other other similar problems.

## So My Data Appears Structured, But Just How Structured?
I like experimenting using Jupyter Notebook during these situations. I'll start a driver, get to the webpage of interest, and start trying out some xpath values using the Chrome Inspect tool and/or the notebook cells. At this point, I tried to create an xpath in the Inspect tool that could isolate a form data field element. When I successfully structured a few xpath statements, I try to generalize across other elements. What do these xpaths seem to have in common? What can I learn from this? Is the the rendered UI potentially also giving clues about which elements might share underlying skeleton structure? Does the form treat all select tags the same? All input tags? Because I knew that everything I wanted was under a div with an attribute of `data-parametername`, I tried to list all of their descendants. The part that was a moment of Eureka! is when I called `set` on this list of descendants across all form elements. It turns out there were only 3 unique HTML structures that led to a data field element. With only 3 structures to plan for, a general parser was closer to reality. As messy as it seemed before, this data was more structured than anticipated (which is a great thing!)

## Iteration and Data Structures
My approach at this point is a lot of trial and error. I go back and forth between the Inspector tool to try out xpaths or to look at the HTML more closely. When I'm in the notebook, I try to run a cell to note how it affects the UI in the Selenium window. Ultimately, I need a structure that's going to house all of this data and a path toward manipulating it in a straightforward manner. Since I'm dynamically parsing the forms, the user needs to be provided a list of valid options until such a time that they don't need the list anymore (they've already run this before and know the options for this page which hopefully hasn't changed since the last time). The final structure I landed on looked something like this: [picture or structure/code block]